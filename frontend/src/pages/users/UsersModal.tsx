import { useEffect, useState, useCallback, Fragment } from "react";
import Button from "../../components/Button";
import Field from "../../components/Field";
import usePostPutData from "../../hooks/usePostPutData";
import type { SelectionOptions } from "../../components/Selection";
import type { ValidationSchema } from "../../utils/validateAndSanitize";
import validateAndSanitize from "../../utils/validateAndSanitize";
import Icon from "../../components/Icon";
import Selection from "../../components/Selection";
import { toastWarning } from "../../utils/toastWarning";
import ErrorModal from "../../components/ErrorModal";
import api from "../../utils/axiosInstance";
import { invalidateCache } from "../../hooks/useGetData";
import PaymentDatePicker from "../../components/PaymentDatePicker";
import { getBranches } from "../../services/branchService";

export type FormData = {
    profile?: File | null;
    name?: string;
    username?: string;
    phone?: number;
    email?: string;
    roles: string[];
    branches?: string[];
    commission?: number;
    userConnectingRoleIds?: Record<string, any>[];
    autoGenerated?: { branchId: string, payComponents: Component[] };
    remarks?: string;
};

export type Component = {
    componentName?: string;
    amount?: number | null;
    schedules?: number[] | null;
    componentId: string;
};

const formSchemaGeneral: ValidationSchema = {
    name: { required: true },
    username: { required: true },
    email: { label: "Email Address" },
    phone: { required: true, label: "Phone Number" },
    roles: { required: true, label: "role", minLength: 1 },
    remarks: { required: true }
};

const formSchemaAdminEmployee: ValidationSchema = {
    branches: { required: true, label: "branch", minLength: 1 },
};

const formSchemaContractor: ValidationSchema = {
    branches: { required: true, label: "branch", minLength: 1 },
    commission: { required: true, type: "number", min: 0, max: 100 }
};

type UsersModalProps = {
    branchOptions?: SelectionOptions[];
    roleOptions?: (SelectionOptions & { baseRoleName: string })[];
    setShowModal: (action: "create" | "edit" | "password" | null) => void;
    onSuccess: () => void;
    action: "create" | "edit" | "password" | null;
    presetData: FormData;
    id?: string;
};

export default function UsersModal({
    branchOptions = [],
    roleOptions = [],
    setShowModal,
    onSuccess,
    action,
    presetData,
    id,
}: UsersModalProps) {
    const [formData, setFormData] = useState<FormData>(presetData);
    const [newComponents, setNewComponents] = useState<Component[]>([]);
    const [existingComponents, setExistingComponents] = useState<Component[]>([]);
    const { error, closeError, loading, postData, putData } = usePostPutData("/api/users");

    const closeModal = () => setShowModal(null);
    const [componentsOptions, setComponentsOptions] = useState<SelectionOptions[]>([]);
    const [availableComponents, setAvailableComponents] = useState<any[]>([]);

    // Initialize existing components from presetData
    useEffect(() => {
        if (presetData.autoGenerated?.payComponents && presetData.autoGenerated?.payComponents.length > 0) {
            const initialExistingComponents = presetData.autoGenerated?.payComponents.map(comp => ({
                componentId: comp.componentId,
                componentName: comp.componentName,
                amount: comp.amount,
                schedules: comp.schedules || []
            }));
            setExistingComponents(initialExistingComponents);
        }
    }, [presetData]);

    useEffect(() => {
        console.log("FORM:", formData)
        console.log("FORM:", formData)
        console.log("FORM:", formData)
    }, [formData])

    useEffect(() => {
        const allPayComponents = [
            ...existingComponents,
            ...newComponents
        ].map(comp => ({
            componentId: comp.componentId,
            componentName: comp.componentName || "",
            amount: comp.amount || 0,
            schedules: comp.schedules || []
        }));

        // Always provide a branchId, default to empty string if not available
        const branchId = formData.autoGenerated?.branchId || "";

        setFormData({
            ...formData,
            autoGenerated: {
                branchId, // This is now guaranteed to be a string (never undefined)
                payComponents: allPayComponents
            }
        });
    }, [newComponents, existingComponents]);

    // Role add/remove logic
    const addRole = () => {
        const selectedRoles = (formData.roles || [])
            .map((id) => roleOptions.find((r) => r.value === id))
            .filter(Boolean) as { baseRoleName: string }[];

        const hasRestricted = selectedRoles.some((r) =>
            ["_CUSTOMER_", "_CONTRACTOR_"].includes(r.baseRoleName)
        );

        if (hasRestricted) {
            toastWarning(
                "You cannot add another role to a Customer or Contractor."
            );
            return;
        }

        setFormData((prev) => ({
            ...prev,
            roles: [...(prev.roles || []), ""],
        }));
    };

    const updateRole = (index: number, value: string) => {
        const selectedRole = roleOptions.find((r) => r.value === value);

        // Reset commission if selected base role is not contractor
        if (selectedRole && !["_CONTRACTOR_"].includes(selectedRole.baseRoleName)) {
            setFormData(prev => ({ ...prev, commission: undefined }));
        }

        // If user selected a restricted role (customer or contractor)
        if (selectedRole && ["_CUSTOMER_", "_CONTRACTOR_"].includes(selectedRole.baseRoleName)) {
            setFormData((prev) => ({
                ...prev,
                roles: [value],
            }));
            return;
        }

        setFormData((prev) => {
            const currentRoles = (prev.roles || [])
                .map((id) => roleOptions.find((r) => r.value === id))
                .filter(Boolean) as { baseRoleName: string }[];

            const hasRestricted = currentRoles.some((r) =>
                ["_CUSTOMER_", "_CONTRACTOR_"].includes(r.baseRoleName)
            );

            if (hasRestricted) {
                toastWarning("Cannot mix Customer or Contractor with other roles.");
                return prev;
            }

            const updated = [...(prev.roles || [])];
            updated[index] = value;
            return { ...prev, roles: updated };
        });
    };

    const removeRole = (index: number) => {
        setFormData((prev) => {
            const updated = [...(prev.roles || [])];
            updated.splice(index, 1);
            return { ...prev, roles: updated, commission: undefined };
        });
    };

    // Determine baseRole group of selected roles
    const selectedRoles = (formData.roles || [])
        .map((id) => roleOptions.find((r) => r.value === id))
        .filter(Boolean);

    const selectedBaseRoles = Array.from(
        new Set(selectedRoles.map((r) => r!.baseRoleName))
    );

    const hasContractorBaseRole = selectedRoles.some(
        (role) => role?.baseRoleName === "_CONTRACTOR_"
    );

    const hasEmployeeBaseRole = selectedRoles.some(
        (role) => role?.baseRoleName === "_EMPLOYEE_"
    );

    const hasAdminEmployeeBaseRole = selectedRoles.some(
        (role) => role?.baseRoleName === "_ADMIN_" || role?.baseRoleName === "_EMPLOYEE_"
    );

    const hasAdminBaseRole = selectedRoles.some(
        (role) => role?.baseRoleName === "_ADMIN_"
    );

    const filteredRoleOptions =
        selectedBaseRoles.length === 0
            ? roleOptions
            : roleOptions.filter(
                (r) =>
                    selectedBaseRoles.includes(r.baseRoleName) ||
                    (selectedBaseRoles.includes("_EMPLOYEE_") &&
                        r.baseRoleName === "_ADMIN_") ||
                    (selectedBaseRoles.includes("_ADMIN_") &&
                        r.baseRoleName === "_EMPLOYEE_")
            );

    const showBranches = !selectedBaseRoles.includes("_CUSTOMER_") && selectedBaseRoles.length > 0;

    const toggleBranch = (value: string) => {
        setFormData((prev) => {
            const existing = prev.branches || [];
            const updated = existing.includes(value)
                ? existing.filter((v) => v !== value)
                : [...existing, value];
            return { ...prev, branches: updated };
        });
    };

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        // Determine which schema to use based on selected roles
        const formSchema = { ...formSchemaGeneral, ...(hasContractorBaseRole ? formSchemaContractor : hasAdminEmployeeBaseRole ? formSchemaAdminEmployee : {}) }
        const { validatedData, isValid } = validateAndSanitize(formData, formSchema);
        if (!isValid) return;

        const multipartFormData = new FormData();
        multipartFormData.append("name", validatedData.name || "");
        multipartFormData.append("username", validatedData.username || "");
        multipartFormData.append("phone", validatedData.phone?.toString() || "");
        multipartFormData.append("roles", JSON.stringify(validatedData.roles || []));

        if (validatedData.branches && validatedData.branches.length > 0) {
            multipartFormData.append("branches", JSON.stringify(validatedData.branches || []));
        }
        if (validatedData.email) {
            multipartFormData.append("email", validatedData.email);
        }
        if (validatedData.commission) {
            multipartFormData.append("commission", (validatedData.commission / 100).toString());
        }
        if (formData.profile) {
            multipartFormData.append("image", formData.profile);
        }

        if (hasEmployeeBaseRole) {
            multipartFormData.append("autoGenerated", JSON.stringify(
                validatedData.autoGenerated || { branchId: "", payComponents: [] }
            ));
        }


        const success =
            action === "create"
                ? await postData(multipartFormData)
                : await putData(id, multipartFormData);

        if (success) {
            onSuccess();
            setFormData({ roles: [] });
            setNewComponents([]);
            setExistingComponents([]);
            closeModal();

            formData.userConnectingRoleIds?.forEach((roleRecord) => {
                invalidateCache(`/api/${roleRecord.role}s/${roleRecord.id}`);
            });
            invalidateCache(`/api/approval-logs`);
            invalidateCache(`/api/activity-logs`);
        }
    };

    const removeComponent = useCallback((id: string) => {
        // Check if component exists in existingComponents (starts with 'existing-')
        if (id.startsWith('existing-')) {
            setExistingComponents(prev => prev.filter(comp => comp.componentId !== id));
        } else {
            // Check if it's a new component or an existing one without prefix
            const inExisting = existingComponents.some(comp => comp.componentId === id);
            if (inExisting) {
                setExistingComponents(prev => prev.filter(comp => comp.componentId !== id));
            } else {
                setNewComponents(prev => prev.filter(comp => comp.componentId !== id));
            }
        }
    }, [existingComponents]);

    const addComponent = useCallback(() => {
        const newId = `new-component-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        setNewComponents(prev => [...prev, {
            componentId: newId,
            componentName: `New Component ${prev.length + 1}`,
            amount: 0,
            schedules: []
        }]);
    }, []);

    const updateComponent = useCallback((id: string, field: keyof Component, value: any) => {
        // Check if component exists in existingComponents
        const isExisting = existingComponents.some(comp => comp.componentId === id);

        if (isExisting) {
            setExistingComponents(prev =>
                prev.map(comp =>
                    comp.componentId === id ? { ...comp, [field]: field === "amount" ? value * 100 : value } : comp
                )
            );
        } else {
            // Must be in newComponents
            setNewComponents(prev =>
                prev.map(comp =>
                    comp.componentId === id ? { ...comp, [field]: field === "amount" ? value * 100 : value } : comp
                )
            );
        }
    }, [existingComponents]);

    useEffect(() => {
        if (showBranches && branchOptions.length > 0) {
            setFormData((prev) => {
                if (!prev.branches || prev.branches.length === 0) {
                    return { ...prev, branches: [branchOptions[0].value] };
                }
                return prev;
            });
        }
    }, [showBranches, branchOptions]);

    useEffect(() => {
        console.log("FORM DATA:", formData);
        console.log("Existing Components:", existingComponents);
        console.log("New Components:", newComponents);
    }, [formData, existingComponents, newComponents]);

    useEffect(() => {
        const fetchComponentsOptions = async () => {
            try {
                const response = await api.get('/api/components');
                const components = response.data.data || [];
                setAvailableComponents(components);

                const compOptions = components.map((component: any) => ({
                    value: component.id,
                    label: component.componentName || 'Unnamed Component'
                }));

                setComponentsOptions([
                    ...compOptions as SelectionOptions[],
                    { value: 'new', label: '+ New Component' }
                ]);
            } catch (error) {
                console.error('Error fetching components:', error);
                setComponentsOptions([{ value: 'new', label: '+ New Component' }]);
            }
        };

        if (hasEmployeeBaseRole) {
            fetchComponentsOptions();
        } else {
            setComponentsOptions([]);
            setAvailableComponents([]);
        }
    }, [hasEmployeeBaseRole]);

    const handleComponentSelection = useCallback((selectedValue: string) => {
        if (selectedValue === 'new') {
            addComponent();
        } else {
            const selectedComponent = availableComponents.find(comp => comp.id === selectedValue);
            if (selectedComponent) {
                // Check if component already exists in either array
                const alreadyExists = [...existingComponents, ...newComponents].some(
                    comp => comp.componentId === selectedValue
                );
                if (!alreadyExists) {
                    setExistingComponents(prev => [...prev, {
                        componentId: selectedComponent.id,
                        componentName: selectedComponent.componentName,
                        amount: 0,
                        schedules: []
                    }]);
                }
            }
        }
    }, [availableComponents, existingComponents, newComponents, addComponent]);

    const allComponents = [...existingComponents, ...newComponents];

    return (
        <>
            {error ? <ErrorModal error={error!} closeError={closeError} /> :
                <>
                    <form onSubmit={handleSubmit} className="card modal gap-[20px] max-w-3xl">
                        <div className="text-xl flex justify-between items-center">
                            <h2 className="font-bold">
                                {action === "edit" ? "Edit User" : "Add User"}
                            </h2>
                            <button type="button" className="cursor-pointer" onClick={closeModal}>
                                âœ•
                            </button>
                        </div>

                        <div className="fields grid gap-[20px]">
                            <fieldset className="card">
                                <h4 className="text-lg font-bold mb-5">Profile Picture</h4>
                                <Field.Image
                                    onChange={(e) =>
                                        setFormData({
                                            ...formData,
                                            profile: e.target.files ? e.target.files[0] : null,
                                        })}
                                />
                            </fieldset>

                            <fieldset className="card">
                                <h4 className="text-lg font-bold mb-5">Personal Information</h4>
                                <div className="grid grid-cols-[repeat(auto-fit,minmax(200px,1fr))] gap-x-10 gap-y-[20px]">
                                    <Field.Text
                                        id="name"
                                        label="Name"
                                        value={formData.name}
                                        onChange={(e) =>
                                            setFormData({ ...formData, name: e.target.value })
                                        }
                                    />
                                    <Field.Text
                                        id="username"
                                        label="Username"
                                        value={formData.username}
                                        readonly={action === "edit"}
                                        onChange={(e) =>
                                            setFormData({ ...formData, username: e.target.value })
                                        }
                                    />
                                    <Field.Email
                                        id="email"
                                        label="Email"
                                        value={formData.email}
                                        onChange={(e) =>
                                            setFormData({ ...formData, email: e.target.value })
                                        }
                                    />
                                    <Field.Number
                                        id="phone"
                                        label="Phone Number"
                                        noSpinner
                                        min={0}
                                        max={9999999999}
                                        value={formData.phone}
                                        onChange={(e) =>
                                            setFormData({ ...formData, phone: Number(e.target.value) })
                                        }
                                    />
                                </div>
                            </fieldset>

                            <fieldset className="card">
                                <div className="mb-5 flex justify-between items-center">
                                    <h4 className="text-lg font-semibold">Roles</h4>
                                    <Button
                                        size="mini"
                                        variant="outline"
                                        label="Add Role"
                                        onClick={addRole}
                                        disabled={
                                            (formData.roles || [])
                                                .map((id) => roleOptions.find((r) => r.value === id))
                                                .some((r) =>
                                                    ["_CUSTOMER_", "_CONTRACTOR_"].includes(r?.baseRoleName || "")
                                                )
                                        }
                                    />
                                </div>

                                <div className="space-y-3">
                                    {(formData.roles || []).map((roleId, i) => (
                                        <div key={i} className="flex items-center gap-2">
                                            <Selection
                                                placeholder="Select a role"
                                                options={filteredRoleOptions}
                                                value={roleId}
                                                onChange={(e) => updateRole(i, e.target.value)}
                                            />
                                            <button
                                                type="button"
                                                onClick={() => removeRole(i)}
                                                className="p-1 text-gray-500 hover:text-red-600"
                                            >
                                                <Icon name="delete" color="dark" />
                                            </button>
                                        </div>
                                    ))}

                                    {formData.roles?.length === 0 && (
                                        <p className="text-sm text-gray-500">
                                            No roles selected yet.
                                        </p>
                                    )}
                                </div>
                            </fieldset>

                            {(showBranches || hasContractorBaseRole || hasEmployeeBaseRole) &&
                                <fieldset className="card">
                                    <h4 className="text-lg font-bold mb-5">Additional Information</h4>

                                    <div className="grid grid-cols-[repeat(auto-fit,minmax(200px,1fr))] gap-x-10 gap-y-[30px]">
                                        {showBranches && (
                                            <div>
                                                <label className="block mb-2">Branches</label>
                                                <div className="flex flex-wrap gap-2">
                                                    {branchOptions.map((branch) => (
                                                        <button
                                                            key={branch.value}
                                                            type="button"
                                                            onClick={() => toggleBranch(branch.value)}
                                                            className={`px-3 py-1 rounded-full border ${formData.branches?.includes(branch.value)
                                                                ? "bg-primary text-white border-primary"
                                                                : "bg-gray-100 text-gray-700 border-gray-300"
                                                                }`}
                                                        >
                                                            {branch.label}
                                                        </button>
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {hasContractorBaseRole &&
                                            <Field.Number
                                                id="commission"
                                                label="Commission (%)"
                                                noSpinner
                                                min={0}
                                                max={100}
                                                value={formData.commission}
                                                onChange={(e) =>
                                                    setFormData({ ...formData, commission: Number(e.target.value) })
                                                }
                                            />
                                        }

                                        {hasEmployeeBaseRole && componentsOptions.length > 0 &&
                                            <div className="col-span-full">
                                                <div className="mb-5 flex gap-5 items-center">
                                                    <h4 className="">Auto Generate Pay</h4>
                                                    <Selection
                                                        options={getBranches()}
                                                        value={formData.autoGenerated?.branchId || ""}
                                                        placeholder="Select Branch"
                                                        onChange={(e) => {
                                                            const selectedBranchId = e.target.value;
                                                            setFormData(prev => {
                                                                // Create a new autoGenerated object
                                                                const newAutoGenerated = {
                                                                    ...prev.autoGenerated,
                                                                    branchId: selectedBranchId,
                                                                    // Ensure payComponents exists (empty array if not)
                                                                    payComponents: prev.autoGenerated?.payComponents || []
                                                                };

                                                                return {
                                                                    ...prev,
                                                                    autoGenerated: newAutoGenerated
                                                                };
                                                            });

                                                            // Optional: You might also want to update the branches array
                                                            setFormData(prev => ({
                                                                ...prev,
                                                                branches: [selectedBranchId] // Update branches array with selected branch
                                                            }));
                                                        }}
                                                    />
                                                    <Selection
                                                        options={componentsOptions}
                                                        value=""
                                                        placeholder="Add Component"
                                                        onChange={(e) => handleComponentSelection(e.target.value)}
                                                    />
                                                </div>

                                                {allComponents.length > 0 && (
                                                    <>
                                                        <hr className="my-3" />

                                                        <div className="space-y-6">
                                                            {allComponents.map((component, i) => (
                                                                <Fragment key={component.componentId}>
                                                                    <div className="flex gap-5 items-start">
                                                                        <div className="grid gap-x-5 gap-y-[20px] font-medium justify-items-start min-w-[120px]">
                                                                            <span>Component</span>
                                                                            <span>Amount</span>
                                                                            <span>Schedule Every</span>
                                                                            <button
                                                                                type="button"
                                                                                className="cursor-pointer hover:bg-gray-100 rounded w-auto p-1"
                                                                                onClick={() => removeComponent(component.componentId)}
                                                                            >
                                                                                <Icon name="delete" color="dark" />
                                                                            </button>
                                                                        </div>
                                                                        <div className="flex-1 grid gap-x-3 gap-y-[10px] items-start">
                                                                            <Field.Text
                                                                                id={`${component.componentId}-name`}
                                                                                value={component.componentName}
                                                                                readonly={!component.componentId.startsWith('new')}
                                                                                onChange={(e) => updateComponent(component.componentId, 'componentName', e.target.value)}
                                                                                placeholder="Component name"
                                                                            />
                                                                            <Field.Money
                                                                                id={`${component.componentId}-amount`}
                                                                                value={component.amount != null ? component.amount / 100 : null}
                                                                                onChange={(values) => updateComponent(component.componentId, 'amount', values.floatValue ?? null)}
                                                                            />
                                                                            <PaymentDatePicker
                                                                                onChange={(scheds) => updateComponent(component.componentId, 'schedules', scheds)}
                                                                                value={component.schedules || []}
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                    {i < allComponents.length - 1 && <hr />}
                                                                </Fragment>
                                                            ))}
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        }
                                    </div>
                                </fieldset>
                            }

                            {action === 'edit' &&
                                <fieldset className="card">
                                    <h4 className="text-lg font-bold mb-3">Remarks</h4>
                                    <Field.TextArea
                                        id="remarks"
                                        value={formData.remarks}
                                        onChange={(e) => {
                                            setFormData({ ...formData, remarks: e.target.value });
                                        }}
                                    />
                                </fieldset>
                            }
                        </div>

                        <div className="flex justify-end items-center gap-[20px]">
                            <Button variant="gray" label="Cancel" onClick={closeModal} />
                            {action === 'create'
                                ? <Button type="submit" variant="primary" label={loading ? "Adding..." : "Add User"} disabled={loading} />
                                : <Button type="submit" variant="primary" label={loading ? "Saving..." : "Save"} disabled={loading} />
                            }
                        </div>
                    </form>

                    <div className="backdrop"></div>
                </>
            }
        </>
    );
}